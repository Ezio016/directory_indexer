<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="DirIndex">
    
    <title>Directory Indexer</title>
    <link rel="manifest" href="app/static/manifest.json">
    <link rel="apple-touch-icon" href="app/static/icon-192.png">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .app-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 5px;
            font-size: 1.8em;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        
        .info-box {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #4caf50;
        }
        
        .info-box p {
            color: #2e7d32;
            margin: 5px 0;
            font-size: 0.9em;
        }
        
        .upload-section {
            margin-bottom: 20px;
        }
        
        .folder-btn {
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: transform 0.1s, opacity 0.2s;
        }
        
        .folder-btn:active {
            transform: scale(0.98);
        }
        
        .folder-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .selected-folder {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }
        
        .selected-folder.show {
            display: block;
        }
        
        .selected-folder strong {
            color: #667eea;
        }
        
        .process-btn {
            width: 100%;
            padding: 15px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.1s;
        }
        
        .process-btn:active {
            transform: scale(0.98);
        }
        
        .process-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        #result {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }
        
        #result.show {
            display: block;
        }
        
        #result.error {
            background: #fee;
            color: #c00;
        }
        
        #result.success {
            background: #efe;
            color: #060;
        }
        
        .preview {
            max-height: 300px;
            overflow-y: auto;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 0.85em;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .download-btn {
            display: inline-block;
            padding: 15px 20px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border: none;
            border-radius: 8px;
            margin: 5px;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.2s;
        }
        
        .download-btn:active {
            transform: scale(0.95);
            background: #5568d3;
        }
        
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            color: #856404;
            font-size: 0.9em;
        }
        
        .progress-container {
            margin: 15px 0;
            display: none;
        }
        
        .progress-container.show {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.15s ease-out;
        }
        
        .progress-text {
            font-size: 0.85em;
            color: #666;
            text-align: center;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .stat-item {
            background: #f0f0f0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
        }
        
        .stat-item strong {
            color: #667eea;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .processing {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="app-icon">üìÅ</div>
            <h1>Directory Indexer</h1>
            <p class="subtitle" id="deviceInfo">Optimized Hybrid Pipeline</p>
        </div>
        
        <div class="info-box" id="infoBox">
            <p><strong>‚ú® Works on all devices!</strong></p>
            <p>üì± iPhone, iPad, Android, Mac, Windows</p>
            <p>üîí Files never leave your device</p>
            <p>‚ö° Mobile-optimized processing</p>
        </div>
        
        <div class="warning" id="compatWarning" style="display: none;"></div>
        
        <div class="upload-section">
            <button class="folder-btn" id="selectBtn">
                üìÇ Select Folder from Your Device
            </button>
            
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>
            
            <div class="selected-folder" id="selectedInfo">
                <strong>Selected:</strong> <span id="folderName"></span><br>
                <strong>Files:</strong> <span id="fileCount">0</span> items
                <div class="stats" id="statsContainer"></div>
            </div>
            
            <div id="formatOptions" style="display: none; margin: 15px 0;">
                <p style="font-weight: 600; margin-bottom: 10px; color: #333;">Select formats:</p>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="checkJSON" checked style="width: 20px; height: 20px;">
                        <span>üìÑ JSON</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="checkXML" style="width: 20px; height: 20px;">
                        <span>üìÑ XML</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="checkTXT" checked style="width: 20px; height: 20px;">
                        <span>üìÑ TXT</span>
                    </label>
                </div>
            </div>
            
            <button class="process-btn" id="processBtn" style="display: none;">
                üöÄ Generate Index
            </button>
        </div>
        
        <div id="result"></div>
    </div>
    
    <script>
        // ==================== DEVICE DETECTION ====================
        
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        const hasDirectoryPicker = 'showDirectoryPicker' in window;
        
        // Mobile-optimized settings
        const CONFIG = {
            chunkSize: isMobile ? 20 : 50,          // Smaller chunks on mobile
            yieldInterval: isMobile ? 10 : 50,      // More frequent yields on mobile
            maxItems: isMobile ? 50000 : 100000,    // Lower limit on mobile
            processBatchSize: isMobile ? 50 : 200   // Smaller batches on mobile
        };
        
        // Update device info
        document.getElementById('deviceInfo').textContent = 
            isMobile ? 'üì± Mobile Mode' : 'üíª Desktop Mode';
        
        // ==================== UTILITY FUNCTIONS ====================
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function showProgress(show = true) {
            document.getElementById('progressContainer').classList.toggle('show', show);
        }
        
        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = `${Math.min(100, percent)}%`;
            document.getElementById('progressText').textContent = text;
        }
        
        function showError(message) {
            const result = document.getElementById('result');
            result.className = 'show error';
            result.innerHTML = `<h3>‚ùå Error</h3><p>${message}</p>`;
            showProgress(false);
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeXml(str) {
            return str.replace(/[<>&'"]/g, c => 
                ({ '<': '&lt;', '>': '&gt;', '&': '&amp;', "'": '&apos;', '"': '&quot;' })[c]
            );
        }
        
        // ==================== CHUNKED PROCESSING ====================
        
        /**
         * Process array in chunks with yields to keep UI responsive
         */
        async function processInChunks(items, processFn, chunkSize, onProgress) {
            const results = [];
            for (let i = 0; i < items.length; i += chunkSize) {
                const chunk = items.slice(i, i + chunkSize);
                for (const item of chunk) {
                    results.push(processFn(item));
                }
                if (onProgress) {
                    onProgress(Math.min(i + chunkSize, items.length), items.length);
                }
                // Yield to UI - critical for mobile
                await sleep(0);
            }
            return results;
        }
        
        /**
         * Build hierarchy with chunked processing (mobile-friendly)
         */
        async function buildHierarchyChunked(files, onProgress) {
            const tree = [];
            const pathToNode = new Map();
            const batchSize = CONFIG.processBatchSize;
            
            for (let i = 0; i < files.length; i += batchSize) {
                const batch = files.slice(i, i + batchSize);
                
                for (const file of batch) {
                    const parts = file.path.split('/').filter(p => p);
                    let currentLevel = tree;
                    let numbering = [];
                    let currentPath = '';
                    
                    for (let j = 0; j < parts.length; j++) {
                        const part = parts[j];
                        currentPath = currentPath ? `${currentPath}/${part}` : part;
                        const isLast = j === parts.length - 1;
                        
                        let existing = pathToNode.get(currentPath);
                        
                        if (!existing) {
                            const position = currentLevel.length + 1;
                            const newNumbering = [...numbering, position];
                            
                            existing = {
                                number: newNumbering.join('.'),
                                name: part,
                                type: isLast && !file.isDir ? 'file' : 'directory',
                                path: currentPath,
                                children: []
                            };
                            
                            currentLevel.push(existing);
                            pathToNode.set(currentPath, existing);
                        }
                        
                        numbering = existing.number.split('.').map(Number);
                        currentLevel = existing.children;
                    }
                }
                
                if (onProgress) {
                    onProgress(Math.min(i + batchSize, files.length), files.length);
                }
                
                // Yield to UI after each batch
                await sleep(0);
            }
            
            return tree;
        }
        
        /**
         * Generate outputs with chunked processing
         */
        async function generateOutputsChunked(hierarchy, folderName, formats, onProgress) {
            const data = { root: folderName, hierarchy };
            const outputs = {};
            
            if (formats.json) {
                onProgress('json', 'Generating JSON...');
                await sleep(0);
                outputs.json = JSON.stringify(data, null, 2);
            }
            
            if (formats.txt) {
                onProgress('txt', 'Generating TXT...');
                outputs.txt = await generateTXTChunked(data);
            }
            
            if (formats.xml) {
                onProgress('xml', 'Generating XML...');
                outputs.xml = await generateXMLChunked(data);
            }
            
            return outputs;
        }
        
        async function generateTXTChunked(data) {
            let txt = `Directory Index: ${data.root}\n`;
            txt += '='.repeat(60) + '\n\n';
            
            let count = 0;
            const batchSize = CONFIG.processBatchSize;
            
            async function formatItems(items, depth = 0) {
                for (const item of items) {
                    const indent = '  '.repeat(depth);
                    const icon = item.type === 'directory' ? 'üìÅ' : 'üìÑ';
                    txt += `${indent}${item.number}. ${icon} ${item.name}\n`;
                    count++;
                    
                    if (count % batchSize === 0) {
                        await sleep(0);
                    }
                    
                    if (item.children?.length) {
                        await formatItems(item.children, depth + 1);
                    }
                }
            }
            
            await formatItems(data.hierarchy);
            return txt;
        }
        
        async function generateXMLChunked(data) {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += `<directory_index root_path="${escapeXml(data.root)}">\n`;
            
            let count = 0;
            const batchSize = CONFIG.processBatchSize;
            
            async function addItems(items, indent = 1) {
                const spaces = '  '.repeat(indent);
                for (const item of items) {
                    xml += `${spaces}<item number="${item.number}" type="${item.type}">\n`;
                    xml += `${spaces}  <name>${escapeXml(item.name)}</name>\n`;
                    xml += `${spaces}  <path>${escapeXml(item.path)}</path>\n`;
                    
                    if (item.children?.length) {
                        xml += `${spaces}  <children>\n`;
                        await addItems(item.children, indent + 2);
                        xml += `${spaces}  </children>\n`;
                    }
                    
                    xml += `${spaces}</item>\n`;
                    count++;
                    
                    if (count % batchSize === 0) {
                        await sleep(0);
                    }
                }
            }
            
            await addItems(data.hierarchy);
            xml += '</directory_index>';
            return xml;
        }
        
        // ==================== FILE READING ====================
        
        /**
         * Read directory using modern API (desktop)
         */
        async function readDirectoryModern(dirHandle, onProgress) {
            const files = [];
            const queue = [{ handle: dirHandle, path: '' }];
            
            while (queue.length > 0) {
                const { handle, path } = queue.shift();
                
                try {
                    for await (const entry of handle.values()) {
                        if (entry.name.startsWith('.')) continue;
                        
                        const fullPath = path ? `${path}/${entry.name}` : entry.name;
                        
                        files.push({
                            path: fullPath,
                            name: entry.name,
                            isDir: entry.kind === 'directory'
                        });
                        
                        if (entry.kind === 'directory') {
                            queue.push({ handle: entry, path: fullPath });
                        }
                        
                        if (files.length % CONFIG.yieldInterval === 0) {
                            onProgress(files.length);
                            await sleep(0);
                        }
                        
                        if (files.length > CONFIG.maxItems) {
                            throw new Error(`Too many items (>${CONFIG.maxItems.toLocaleString()}). Try a smaller folder.`);
                        }
                    }
                } catch (err) {
                    if (err.message.includes('Too many')) throw err;
                    console.warn(`Skipped: ${path}`, err.message);
                }
            }
            
            return files;
        }
        
        /**
         * Process files from input (mobile fallback) with chunked processing
         */
        async function processFileInputChunked(fileList, onProgress) {
            const files = [];
            const dirs = new Set();
            const batchSize = CONFIG.chunkSize;
            
            // Process in chunks to avoid blocking
            for (let i = 0; i < fileList.length; i += batchSize) {
                const batch = Array.from(fileList).slice(i, i + batchSize);
                
                for (const file of batch) {
                    const pathParts = file.webkitRelativePath.split('/');
                    const relativePath = pathParts.slice(1).join('/');
                    
                    if (file.name.startsWith('.')) continue;
                    
                    files.push({
                        path: relativePath,
                        name: file.name,
                        isDir: false
                    });
                    
                    // Collect directory paths
                    for (let j = 1; j < pathParts.length - 1; j++) {
                        const dirPath = pathParts.slice(1, j + 1).join('/');
                        if (!dirPath.split('/').some(p => p.startsWith('.'))) {
                            dirs.add(dirPath);
                        }
                    }
                }
                
                onProgress(Math.min(i + batchSize, fileList.length), fileList.length);
                await sleep(0); // Yield to UI
            }
            
            // Add directories
            for (const dir of dirs) {
                files.push({
                    path: dir,
                    name: dir.split('/').pop(),
                    isDir: true
                });
            }
            
            return files;
        }
        
        // ==================== STATE ====================
        
        let folderName = '';
        let folderHandle = null;
        let collectedFiles = [];
        let hierarchy = [];
        
        // ==================== MAIN FLOW ====================
        
        // Setup based on device capabilities
        if (!hasDirectoryPicker) {
            if (isIOS) {
                document.getElementById('compatWarning').style.display = 'block';
                document.getElementById('compatWarning').innerHTML = 
                    'üì± <strong>iOS Mode:</strong> Tap the button, then select a folder from Files app.';
            }
            setupFileInputFallback();
        }
        
        // Select folder button
        document.getElementById('selectBtn').addEventListener('click', async () => {
            try {
                if (hasDirectoryPicker) {
                    await selectFolderModern();
                } else {
                    document.getElementById('fileInput')?.click();
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showError(error.message);
                }
            }
        });
        
        async function selectFolderModern() {
            const selectBtn = document.getElementById('selectBtn');
            
            try {
                folderHandle = await window.showDirectoryPicker();
                folderName = folderHandle.name;
                
                selectBtn.disabled = true;
                selectBtn.classList.add('processing');
                selectBtn.textContent = '‚è≥ Reading...';
                showProgress(true);
                
                const startTime = performance.now();
                
                collectedFiles = await readDirectoryModern(folderHandle, (count) => {
                    const elapsed = (performance.now() - startTime) / 1000;
                    const rate = Math.round(count / Math.max(0.1, elapsed));
                    updateProgress(
                        Math.min(90, (count / 500) * 9),
                        `Reading... ${count.toLocaleString()} items (${rate}/sec)`
                    );
                });
                
                // Sort: directories first, then alphabetically
                collectedFiles.sort((a, b) => {
                    if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
                    return a.path.localeCompare(b.path);
                });
                
                showReadComplete();
                
            } catch (error) {
                selectBtn.disabled = false;
                selectBtn.classList.remove('processing');
                selectBtn.textContent = 'üìÇ Select Folder';
                showProgress(false);
                
                if (error.name !== 'AbortError') {
                    showError(error.message);
                }
            }
        }
        
        function setupFileInputFallback() {
            const input = document.createElement('input');
            input.type = 'file';
            input.id = 'fileInput';
            input.webkitdirectory = true;
            input.multiple = true;
            input.style.display = 'none';
            document.body.appendChild(input);
            
            input.addEventListener('change', async (e) => {
                const fileList = e.target.files;
                if (fileList.length === 0) return;
                
                const selectBtn = document.getElementById('selectBtn');
                selectBtn.disabled = true;
                selectBtn.classList.add('processing');
                selectBtn.textContent = '‚è≥ Processing...';
                showProgress(true);
                
                try {
                    if (fileList.length > CONFIG.maxItems) {
                        throw new Error(`Too many files (>${CONFIG.maxItems.toLocaleString()}). Try a smaller folder.`);
                    }
                    
                    folderName = fileList[0].webkitRelativePath.split('/')[0];
                    
                    // Process files in chunks (mobile-friendly)
                    collectedFiles = await processFileInputChunked(fileList, (processed, total) => {
                        updateProgress(
                            (processed / total) * 90,
                            `Processing... ${processed.toLocaleString()}/${total.toLocaleString()}`
                        );
                    });
                    
                    // Sort
                    collectedFiles.sort((a, b) => {
                        if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
                        return a.path.localeCompare(b.path);
                    });
                    
                    showReadComplete();
                    
                } catch (error) {
                    selectBtn.disabled = false;
                    selectBtn.classList.remove('processing');
                    selectBtn.textContent = 'üìÇ Select Folder';
                    showProgress(false);
                    showError(error.message);
                }
            });
        }
        
        function showReadComplete() {
            const selectBtn = document.getElementById('selectBtn');
            
            updateProgress(100, `Found ${collectedFiles.length.toLocaleString()} items`);
            
            document.getElementById('folderName').textContent = folderName;
            document.getElementById('fileCount').textContent = collectedFiles.length.toLocaleString();
            
            const dirs = collectedFiles.filter(f => f.isDir).length;
            const files = collectedFiles.length - dirs;
            document.getElementById('statsContainer').innerHTML = `
                <div class="stat-item"><strong>${dirs.toLocaleString()}</strong> folders</div>
                <div class="stat-item"><strong>${files.toLocaleString()}</strong> files</div>
            `;
            
            document.getElementById('selectedInfo').classList.add('show');
            document.getElementById('formatOptions').style.display = 'block';
            document.getElementById('processBtn').style.display = 'block';
            
            selectBtn.disabled = false;
            selectBtn.classList.remove('processing');
            selectBtn.textContent = 'üìÇ Select Another Folder';
            showProgress(false);
        }
        
        // Generate index button
        document.getElementById('processBtn').addEventListener('click', generateIndex);
        
        async function generateIndex() {
            const btn = document.getElementById('processBtn');
            btn.disabled = true;
            btn.classList.add('processing');
            btn.textContent = '‚è≥ Processing...';
            
            showProgress(true);
            updateProgress(0, 'Starting...');
            
            const formats = {
                json: document.getElementById('checkJSON').checked,
                xml: document.getElementById('checkXML').checked,
                txt: document.getElementById('checkTXT').checked
            };
            
            if (!formats.json && !formats.xml && !formats.txt) {
                showError('Please select at least one format!');
                btn.disabled = false;
                btn.classList.remove('processing');
                btn.textContent = 'üöÄ Generate Index';
                return;
            }
            
            try {
                // Step 1: Build hierarchy (chunked for mobile)
                updateProgress(5, 'Building hierarchy...');
                
                hierarchy = await buildHierarchyChunked(collectedFiles, (processed, total) => {
                    const percent = 5 + (processed / total) * 45;
                    updateProgress(percent, `Building... ${processed.toLocaleString()}/${total.toLocaleString()}`);
                });
                
                // Step 2: Generate outputs (chunked for mobile)
                updateProgress(50, 'Generating outputs...');
                
                const outputs = await generateOutputsChunked(hierarchy, folderName, formats, (step, msg) => {
                    const percents = { json: 55, txt: 70, xml: 85 };
                    updateProgress(percents[step] || 75, msg);
                });
                
                updateProgress(100, 'Complete!');
                await sleep(100);
                
                // Show results
                const result = document.getElementById('result');
                result.className = 'show success';
                
                let downloadButtons = '';
                if (outputs.json) {
                    downloadButtons += `<button class="download-btn" onclick="downloadFile('json')">üìÑ JSON</button>`;
                }
                if (outputs.txt) {
                    downloadButtons += `<button class="download-btn" onclick="downloadFile('txt')">üìÑ TXT</button>`;
                }
                if (outputs.xml) {
                    downloadButtons += `<button class="download-btn" onclick="downloadFile('xml')">üìÑ XML</button>`;
                }
                
                window.generatedOutputs = outputs;
                
                const previewText = outputs.txt || outputs.json || '';
                const truncated = previewText.length > 3000 
                    ? previewText.slice(0, 3000) + '\n\n... (preview truncated)'
                    : previewText;
                
                result.innerHTML = `
                    <h3>‚úÖ Done!</h3>
                    <p><strong>Folder:</strong> ${folderName}</p>
                    <p><strong>Items:</strong> ${collectedFiles.length.toLocaleString()}</p>
                    <p style="margin-top: 15px;"><strong>Download:</strong></p>
                    <div style="margin: 10px 0;">${downloadButtons}</div>
                    <div class="preview">${escapeHtml(truncated)}</div>
                `;
                
                showProgress(false);
                
            } catch (error) {
                showError(error.message);
            } finally {
                btn.disabled = false;
                btn.classList.remove('processing');
                btn.textContent = 'üöÄ Generate Index';
            }
        }
        
        // Download file
        function downloadFile(type) {
            const content = window.generatedOutputs?.[type];
            if (!content) return;
            
            const mimeTypes = { json: 'application/json', xml: 'application/xml', txt: 'text/plain' };
            const blob = new Blob([content], { type: mimeTypes[type] });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `directory_index.${type}`;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            // Visual feedback
            const btn = event.target;
            const original = btn.textContent;
            btn.textContent = '‚úÖ Done!';
            btn.style.background = '#4caf50';
            setTimeout(() => {
                btn.textContent = original;
                btn.style.background = '';
            }, 1500);
        }
        
        // Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('app/static/sw.js').catch(() => {});
        }
    </script>
</body>
</html>
