<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="DirIndex">
    
    <title>Directory Indexer - Streaming Architecture</title>
    <link rel="manifest" href="app/static/manifest.json">
    <link rel="apple-touch-icon" href="app/static/icon-192.png">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .app-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 5px;
            font-size: 1.8em;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        
        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #2196f3;
        }
        
        .info-box p {
            color: #1565c0;
            margin: 5px 0;
            font-size: 0.9em;
        }
        
        .info-box.success {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }
        
        .info-box.success p {
            color: #2e7d32;
        }
        
        .upload-section {
            margin-bottom: 20px;
        }
        
        .folder-btn {
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: transform 0.1s, opacity 0.2s;
        }
        
        .folder-btn:active {
            transform: scale(0.98);
        }
        
        .folder-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .selected-folder {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }
        
        .selected-folder.show {
            display: block;
        }
        
        .selected-folder strong {
            color: #667eea;
        }
        
        .process-btn {
            width: 100%;
            padding: 15px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.1s;
        }
        
        .process-btn:active {
            transform: scale(0.98);
        }
        
        .process-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        #result {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }
        
        #result.show {
            display: block;
        }
        
        #result.error {
            background: #fee;
            color: #c00;
        }
        
        #result.success {
            background: #efe;
            color: #060;
        }
        
        .preview {
            max-height: 300px;
            overflow-y: auto;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 0.85em;
            white-space: pre-wrap;
        }
        
        .download-btn {
            display: inline-block;
            padding: 15px 20px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border: none;
            border-radius: 8px;
            margin: 5px;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.2s;
        }
        
        .download-btn:active {
            transform: scale(0.95);
            background: #5568d3;
        }
        
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            color: #856404;
            font-size: 0.9em;
        }
        
        .progress-container {
            margin: 15px 0;
            display: none;
        }
        
        .progress-container.show {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.15s ease-out;
        }
        
        .progress-text {
            font-size: 0.85em;
            color: #666;
            text-align: center;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .stat-item {
            background: #f0f0f0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
        }
        
        .stat-item strong {
            color: #667eea;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .processing {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="app-icon">üìÅ</div>
            <h1>Directory Indexer</h1>
            <p class="subtitle">Streaming Pipes & Filters + Web Workers</p>
        </div>
        
        <div class="info-box success" id="infoBox">
            <p><strong>‚ú® Now handles large folders!</strong></p>
            <p>üì± Works on iPhone, iPad, Android, Mac, Windows, Linux</p>
            <p>üîí Your files never leave your device</p>
            <p>‚ö° Streaming architecture prevents freezing</p>
            <p>üßµ Web Worker keeps UI responsive</p>
        </div>
        
        <div class="warning" id="compatWarning" style="display: none;">
            ‚ö†Ô∏è Your browser doesn't support folder selection. Please use Chrome, Edge, or Safari on iOS 15.2+
        </div>
        
        <div class="upload-section">
            <button class="folder-btn" id="selectBtn">
                üìÇ Select Folder from Your Device
            </button>
            
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>
            
            <div class="selected-folder" id="selectedInfo">
                <strong>Selected:</strong> <span id="folderName"></span><br>
                <strong>Files:</strong> <span id="fileCount">0</span> items
                <div class="stats" id="statsContainer"></div>
            </div>
            
            <div id="formatOptions" style="display: none; margin: 15px 0;">
                <p style="font-weight: 600; margin-bottom: 10px; color: #333;">Select formats to generate:</p>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="checkJSON" checked style="width: 20px; height: 20px; cursor: pointer;">
                        <span>üìÑ JSON</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="checkXML" checked style="width: 20px; height: 20px; cursor: pointer;">
                        <span>üìÑ XML</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="checkTXT" checked style="width: 20px; height: 20px; cursor: pointer;">
                        <span>üìÑ TXT</span>
                    </label>
                </div>
            </div>
            
            <button class="process-btn" id="processBtn" style="display: none;">
                üöÄ Generate Index
            </button>
        </div>
        
        <div id="result"></div>
    </div>
    
    <script>
        // ==================== STREAMING FILE READER ====================
        
        /**
         * Async generator that reads directory entries in chunks
         * Yields control back to UI after each chunk
         */
        async function* streamDirectoryEntries(dirHandle, basePath = '', chunkSize = 50) {
            let buffer = [];
            
            for await (const entry of dirHandle.values()) {
                if (entry.name.startsWith('.')) continue;
                
                const fullPath = basePath ? `${basePath}/${entry.name}` : entry.name;
                
                buffer.push({
                    path: fullPath,
                    name: entry.name,
                    isDir: entry.kind === 'directory',
                    handle: entry.kind === 'directory' ? entry : null
                });
                
                // Yield chunk when buffer is full
                if (buffer.length >= chunkSize) {
                    yield buffer;
                    buffer = [];
                    // Yield to UI
                    await new Promise(r => setTimeout(r, 0));
                }
            }
            
            // Yield remaining items
            if (buffer.length > 0) {
                yield buffer;
            }
        }
        
        /**
         * Recursively read entire directory tree using streaming
         * Never loads everything into memory at once
         */
        async function* streamDirectoryTreeFlat(dirHandle, basePath = '', onProgress = null) {
            const queue = [{ handle: dirHandle, path: basePath }];
            let totalYielded = 0;
            
            while (queue.length > 0) {
                const { handle, path } = queue.shift();
                
                try {
                    for await (const chunk of streamDirectoryEntries(handle, path)) {
                        for (const entry of chunk) {
                            // Queue subdirectories for later processing
                            if (entry.isDir && entry.handle) {
                                queue.push({ handle: entry.handle, path: entry.path });
                            }
                            
                            // Yield entry without handle (not needed downstream)
                            yield {
                                path: entry.path,
                        name: entry.name,
                                isDir: entry.isDir
                            };
                            
                            totalYielded++;
                            if (onProgress && totalYielded % 100 === 0) {
                                onProgress(totalYielded);
                            }
                        }
                    }
                } catch (err) {
                    console.warn(`Error reading ${path}:`, err.message);
                }
            }
        }
        
        /**
         * Collect stream into array with progress updates
         * Uses chunked collection to stay responsive
         */
        async function collectStreamWithProgress(asyncGenerator, onProgress, maxItems = 100000) {
            const items = [];
            
            for await (const item of asyncGenerator) {
                items.push(item);
                
                if (items.length > maxItems) {
                    throw new Error(`Folder too large (>${maxItems} items). Try a subfolder.`);
                }
                
                // Progress update every 50 items
                if (items.length % 50 === 0) {
                    onProgress(items.length);
                    // Yield to UI
                    await new Promise(r => setTimeout(r, 0));
                }
            }
            
            return items;
                    }
                    
        // ==================== WEB WORKER MANAGER ====================
        
        class WorkerManager {
            constructor() {
                this.worker = null;
                this.pendingResolve = null;
                this.pendingReject = null;
                this.onProgress = null;
            }
            
            init() {
                if (this.worker) return;
                
                try {
                    this.worker = new Worker('app/static/worker.js');
                    this.worker.onmessage = this.handleMessage.bind(this);
                    this.worker.onerror = this.handleError.bind(this);
                } catch (e) {
                    console.warn('Web Worker not available, falling back to main thread');
                    this.worker = null;
                }
            }
            
            handleMessage(e) {
                const { type, ...data } = e.data;
                
                switch (type) {
                    case 'progress':
                        if (this.onProgress) {
                            this.onProgress(data);
                        }
                        break;
                    
                    case 'hierarchyComplete':
                    case 'outputsComplete':
                        if (this.pendingResolve) {
                            this.pendingResolve(data);
                            this.pendingResolve = null;
                            this.pendingReject = null;
                        }
                        break;
                    
                    case 'error':
                        if (this.pendingReject) {
                            this.pendingReject(new Error(data.message));
                            this.pendingResolve = null;
                            this.pendingReject = null;
                        }
                        break;
                }
            }
            
            handleError(e) {
                console.error('Worker error:', e);
                if (this.pendingReject) {
                    this.pendingReject(new Error('Worker error: ' + e.message));
                    }
                }
            
            processFiles(files, onProgress) {
                return new Promise((resolve, reject) => {
                    if (!this.worker) {
                        // Fallback: process on main thread
                        resolve(this.processFilesMainThread(files, onProgress));
                        return;
                    }
                    
                    this.pendingResolve = resolve;
                    this.pendingReject = reject;
                    this.onProgress = onProgress;
                    
                    this.worker.postMessage({
                        action: 'processFiles',
                        payload: { files }
                    });
                });
            }
            
            generateOutputs(hierarchy, folderName, formats, onProgress) {
                return new Promise((resolve, reject) => {
                    if (!this.worker) {
                        // Fallback: process on main thread
                        resolve(this.generateOutputsMainThread(hierarchy, folderName, formats, onProgress));
                        return;
                    }
                    
                    this.pendingResolve = resolve;
                    this.pendingReject = reject;
                    this.onProgress = onProgress;
                    
                    this.worker.postMessage({
                        action: 'generateOutputs',
                        payload: { hierarchy, folderName, formats }
                    });
                });
            }
            
            // Fallback implementations for main thread
            processFilesMainThread(files, onProgress) {
                onProgress({ step: 'sort', message: 'Sorting files...' });
                
                const sorted = [...files].sort((a, b) => {
                if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
                return a.path.localeCompare(b.path);
            });
        
                onProgress({ step: 'hierarchy', message: 'Building hierarchy...' });
                
            const tree = [];
                const pathToNode = new Map();
            
                for (const file of sorted) {
                const parts = file.path.split('/').filter(p => p);
                    let currentLevel = tree;
                let currentPath = '';
                    let numbering = [];
                
                    for (let i = 0; i < parts.length; i++) {
                        const part = parts[i];
                    currentPath = currentPath ? `${currentPath}/${part}` : part;
                        const isLast = i === parts.length - 1;
                    
                        let existing = pathToNode.get(currentPath);
                    
                    if (!existing) {
                            const position = currentLevel.length + 1;
                            const newNumbering = [...numbering, position];
                        
                        existing = {
                                number: newNumbering.join('.'),
                            name: part,
                            type: isLast && !file.isDir ? 'file' : 'directory',
                            path: currentPath,
                            children: []
                        };
                        
                            currentLevel.push(existing);
                            pathToNode.set(currentPath, existing);
                        }
                        
                        numbering = existing.number.split('.').map(Number);
                        currentLevel = existing.children;
                    }
                }
            
                return { hierarchy: tree, itemCount: files.length };
        }
        
            generateOutputsMainThread(hierarchy, folderName, formats, onProgress) {
                const data = { root: folderName, hierarchy };
                const outputs = {};
                
                if (formats.json) {
                    onProgress({ step: 'json', message: 'Generating JSON...' });
                    outputs.json = JSON.stringify(data, null, 2);
        }
        
                if (formats.xml) {
                    onProgress({ step: 'xml', message: 'Generating XML...' });
                    outputs.xml = this.generateXML(data);
                }
                
                if (formats.txt) {
                    onProgress({ step: 'txt', message: 'Generating TXT...' });
                    outputs.txt = this.generateTXT(data);
                }
                
                return { outputs };
            }
            
            generateXML(data) {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += `<directory_index root_path="${escapeXml(data.root)}">\n`;
            
                const addItems = (items, indent = 1) => {
                const spaces = '  '.repeat(indent);
                    for (const item of items) {
                    xml += `${spaces}<item number="${item.number}" type="${item.type}">\n`;
                    xml += `${spaces}  <name>${escapeXml(item.name)}</name>\n`;
                    xml += `${spaces}  <path>${escapeXml(item.path)}</path>\n`;
                        if (item.children?.length > 0) {
                        xml += `${spaces}  <children>\n`;
                        addItems(item.children, indent + 2);
                        xml += `${spaces}  </children>\n`;
                    }
                    xml += `${spaces}</item>\n`;
            }
                };
            
            addItems(data.hierarchy);
            xml += '</directory_index>';
            return xml;
        }
        
            generateTXT(data) {
            let txt = `Directory Index: ${data.root}\n`;
            txt += '='.repeat(80) + '\n\n';
            
                const formatItem = (item, depth = 0) => {
                const indent = '  '.repeat(depth);
                const icon = item.type === 'directory' ? 'üìÅ' : 'üìÑ';
                    txt += `${indent}${item.number}. ${icon} ${item.name}\n`;
                    item.children?.forEach(child => formatItem(child, depth + 1));
                };
            
                data.hierarchy.forEach(item => formatItem(item));
            return txt;
            }
        }
        
        // ==================== STATE ====================
        
        let folderName = '';
        let folderHandle = null;
        let collectedFiles = [];
        let hierarchy = [];
        const workerManager = new WorkerManager();
        
        // ==================== UI HELPERS ====================
        
        function showProgress(show = true) {
            document.getElementById('progressContainer').classList.toggle('show', show);
        }
        
        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = text;
        }
        
        function showError(message) {
            const result = document.getElementById('result');
            result.className = 'show error';
            result.innerHTML = `<h3>‚ùå Error</h3><p>${message}</p>`;
            showProgress(false);
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeXml(str) {
            return str.replace(/[<>&'"]/g, char => ({
                '<': '&lt;', '>': '&gt;', '&': '&amp;', "'": '&apos;', '"': '&quot;'
            })[char]);
        }
        
        // ==================== MAIN FLOW ====================
        
        // Check compatibility
        if (!('showDirectoryPicker' in window)) {
            document.getElementById('compatWarning').style.display = 'block';
            setupFileInputFallback();
        }
        
        // Initialize worker
        workerManager.init();
        
        // Select folder button
        document.getElementById('selectBtn').addEventListener('click', async () => {
            try {
                if ('showDirectoryPicker' in window) {
                    await selectFolderModern();
                } else {
                    document.getElementById('fileInput')?.click();
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showError(error.message);
                }
            }
        });
        
        async function selectFolderModern() {
            const selectBtn = document.getElementById('selectBtn');
            
            try {
                folderHandle = await window.showDirectoryPicker();
                folderName = folderHandle.name;
                
                selectBtn.disabled = true;
                selectBtn.classList.add('processing');
                selectBtn.textContent = '‚è≥ Reading folder...';
                showProgress(true);
                updateProgress(0, 'Starting scan...');
                
                // Stream read with progress
                const startTime = performance.now();
                
                const progressCallback = (count) => {
                    const elapsed = (performance.now() - startTime) / 1000;
                    const rate = Math.round(count / elapsed);
                    updateProgress(
                        Math.min(90, (count / 1000) * 9), 
                        `Reading... ${count.toLocaleString()} items (${rate}/sec)`
                    );
                };
                
                collectedFiles = await collectStreamWithProgress(
                    streamDirectoryTreeFlat(folderHandle, '', progressCallback),
                    progressCallback,
                    100000 // Max 100k items
                );
                
                updateProgress(100, `Found ${collectedFiles.length.toLocaleString()} items`);
                
                // Update UI
                document.getElementById('folderName').textContent = folderName;
                document.getElementById('fileCount').textContent = collectedFiles.length.toLocaleString();
                
                // Stats
                const dirs = collectedFiles.filter(f => f.isDir).length;
                const files = collectedFiles.length - dirs;
                document.getElementById('statsContainer').innerHTML = `
                    <div class="stat-item"><strong>${dirs.toLocaleString()}</strong> folders</div>
                    <div class="stat-item"><strong>${files.toLocaleString()}</strong> files</div>
                `;
                
                document.getElementById('selectedInfo').classList.add('show');
                document.getElementById('formatOptions').style.display = 'block';
                document.getElementById('processBtn').style.display = 'block';
                
                selectBtn.disabled = false;
                selectBtn.classList.remove('processing');
                selectBtn.textContent = 'üìÇ Select Another Folder';
                showProgress(false);
                
            } catch (error) {
                selectBtn.disabled = false;
                selectBtn.classList.remove('processing');
                selectBtn.textContent = 'üìÇ Select Folder from Your Device';
                showProgress(false);
                
                if (error.name !== 'AbortError') {
                    showError(error.message);
                }
            }
        }
        
        function setupFileInputFallback() {
            const input = document.createElement('input');
            input.type = 'file';
            input.id = 'fileInput';
            input.webkitdirectory = true;
            input.multiple = true;
            input.style.display = 'none';
            document.body.appendChild(input);
            
            input.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                
                showProgress(true);
                updateProgress(0, 'Processing files...');
                
                if (files.length > 100000) {
                    showError('Too many files (>100,000). Try a smaller folder.');
                    return;
                }
                
                folderName = files[0].webkitRelativePath.split('/')[0];
                
                // Build file list
                collectedFiles = files.map(file => ({
                    path: file.webkitRelativePath.split('/').slice(1).join('/'),
                    isDir: false,
                    name: file.name
                })).filter(f => !f.name.startsWith('.'));
                
                // Add directories
                const dirs = new Set();
                files.forEach(file => {
                    const parts = file.webkitRelativePath.split('/');
                    for (let i = 1; i < parts.length - 1; i++) {
                        dirs.add(parts.slice(1, i + 1).join('/'));
                    }
                });
                
                dirs.forEach(dir => {
                    if (!dir.split('/').some(p => p.startsWith('.'))) {
                        collectedFiles.push({
                        path: dir,
                        isDir: true,
                        name: dir.split('/').pop()
                    });
                    }
                });
                
                updateProgress(100, `Found ${collectedFiles.length.toLocaleString()} items`);
                
                document.getElementById('folderName').textContent = folderName;
                document.getElementById('fileCount').textContent = collectedFiles.length.toLocaleString();
                document.getElementById('selectedInfo').classList.add('show');
                document.getElementById('formatOptions').style.display = 'block';
                document.getElementById('processBtn').style.display = 'block';
                showProgress(false);
            });
        }
        
        // Generate index button
        document.getElementById('processBtn').addEventListener('click', generateIndex);
        
        async function generateIndex() {
            const btn = document.getElementById('processBtn');
            btn.disabled = true;
            btn.classList.add('processing');
            btn.textContent = '‚è≥ Processing...';
            
            showProgress(true);
            updateProgress(0, 'Starting...');
            
            const formats = {
                json: document.getElementById('checkJSON').checked,
                xml: document.getElementById('checkXML').checked,
                txt: document.getElementById('checkTXT').checked
            };
            
            if (!formats.json && !formats.xml && !formats.txt) {
                showError('Please select at least one format to generate!');
                btn.disabled = false;
                btn.classList.remove('processing');
                btn.textContent = 'üöÄ Generate Index';
                return;
            }
            
            try {
                // Step 1: Build hierarchy
                updateProgress(10, 'Building hierarchy...');
                
                const progressHandler = (data) => {
                    if (data.step === 'hierarchy' && data.processed) {
                        const percent = 10 + (data.processed / collectedFiles.length) * 40;
                        updateProgress(percent, `Building hierarchy... ${data.processed}/${collectedFiles.length}`);
                    } else if (data.step === 'json') {
                        updateProgress(55, 'Generating JSON...');
                    } else if (data.step === 'xml') {
                        updateProgress(70, 'Generating XML...');
                    } else if (data.step === 'txt') {
                        updateProgress(85, 'Generating TXT...');
                    }
                };
                
                const hierarchyResult = await workerManager.processFiles(collectedFiles, progressHandler);
                hierarchy = hierarchyResult.hierarchy;
                
                // Step 2: Generate outputs
                updateProgress(50, 'Generating outputs...');
                
                const outputResult = await workerManager.generateOutputs(
                    hierarchy, folderName, formats, progressHandler
                );
                
                updateProgress(100, 'Complete!');
                
                // Show results
                const result = document.getElementById('result');
                result.className = 'show success';
                
                let downloadButtons = '';
                if (outputResult.outputs.json) {
                    downloadButtons += `<button class="download-btn" onclick="downloadFile('json')">üìÑ Download JSON</button>`;
                }
                if (outputResult.outputs.xml) {
                    downloadButtons += `<button class="download-btn" onclick="downloadFile('xml')">üìÑ Download XML</button>`;
                }
                if (outputResult.outputs.txt) {
                    downloadButtons += `<button class="download-btn" onclick="downloadFile('txt')">üìÑ Download TXT</button>`;
                }
                
                window.generatedOutputs = outputResult.outputs;
                
                result.innerHTML = `
                    <h3>‚úÖ Index Generated!</h3>
                    <p><strong>Folder:</strong> ${folderName}</p>
                    <p><strong>Items:</strong> ${collectedFiles.length.toLocaleString()}</p>
                    <p style="margin-top: 15px;"><strong>Tap to download:</strong></p>
                    <div style="margin: 10px 0;">
                        ${downloadButtons}
                    </div>
                    ${outputResult.outputs.txt ? '<div class="preview">' + escapeHtml(outputResult.outputs.txt.slice(0, 5000)) + (outputResult.outputs.txt.length > 5000 ? '\n\n... (truncated preview)' : '') + '</div>' : ''}
                `;
                
                showProgress(false);
                
            } catch (error) {
                showError(error.message);
            } finally {
                btn.disabled = false;
                btn.classList.remove('processing');
                btn.textContent = 'üöÄ Generate Index';
            }
        }
        
        // Download file
        function downloadFile(type) {
            const content = window.generatedOutputs[type];
            if (!content) return;
            
            const mimeTypes = {
                json: 'application/json',
                xml: 'application/xml',
                txt: 'text/plain'
            };
            
            const blob = new Blob([content], { type: mimeTypes[type] });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
            a.download = `directory_index.${type}`;
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
            // Visual feedback
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Downloaded!';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
        }
        
        // Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('app/static/sw.js')
                .catch(err => console.log('SW registration skipped'));
        }
    </script>
</body>
</html>
