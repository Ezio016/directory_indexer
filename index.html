<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="DirIndex">
    
    <title>Directory Indexer - Pipes & Filters Architecture</title>
    <link rel="manifest" href="app/static/manifest.json">
    <link rel="apple-touch-icon" href="app/static/icon-192.png">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .app-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 5px;
            font-size: 1.8em;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        
        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #2196f3;
        }
        
        .info-box p {
            color: #1565c0;
            margin: 5px 0;
            font-size: 0.9em;
        }
        
        .upload-section {
            margin-bottom: 20px;
        }
        
        .folder-btn {
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .folder-btn:active {
            transform: scale(0.98);
        }
        
        .folder-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .selected-folder {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }
        
        .selected-folder.show {
            display: block;
        }
        
        .selected-folder strong {
            color: #667eea;
        }
        
        .process-btn {
            width: 100%;
            padding: 15px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
        }
        
        .process-btn:active {
            transform: scale(0.98);
        }
        
        .process-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        #result {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }
        
        #result.show {
            display: block;
        }
        
        #result.error {
            background: #fee;
            color: #c00;
        }
        
        #result.success {
            background: #efe;
            color: #060;
        }
        
        .preview {
            max-height: 300px;
            overflow-y: auto;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 0.85em;
            white-space: pre-wrap;
        }
        
        .download-btn {
            display: inline-block;
            padding: 15px 20px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border: none;
            border-radius: 8px;
            margin: 5px;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.2s;
        }
        
        .download-btn:active {
            transform: scale(0.95);
            background: #5568d3;
        }
        
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            color: #856404;
            font-size: 0.9em;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
            display: none;
        }
        
        .progress-bar.show {
            display: block;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="app-icon">üìÅ</div>
            <h1>Directory Indexer</h1>
            <p class="subtitle">Pipes & Filters Architecture + Event-Driven UI</p>
        </div>
        
        <div class="info-box">
            <p><strong>‚ú® Works completely on your device!</strong></p>
            <p>üì± iPhone, iPad, Android, Mac, Windows, Linux</p>
            <p>üîí Your files never leave your device</p>
            <p>üí° Best for folders with < 1,000 files</p>
            <p>üñ•Ô∏è For large folders: use command-line tool on desktop</p>
        </div>
        
        <div class="warning" id="compatWarning" style="display: none;">
            ‚ö†Ô∏è Your browser doesn't support folder selection. Please use Chrome, Edge, or Safari on iOS 15.2+
        </div>
        
        <div class="upload-section">
            <button class="folder-btn" id="selectBtn">
                üìÇ Select Folder from Your Device
            </button>
            
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="selected-folder" id="selectedInfo">
                <strong>Selected:</strong> <span id="folderName"></span><br>
                <strong>Files:</strong> <span id="fileCount">0</span> items
            </div>
            
            <div id="formatOptions" style="display: none; margin: 15px 0;">
                <p style="font-weight: 600; margin-bottom: 10px; color: #333;">Select formats to generate:</p>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="checkJSON" checked style="width: 20px; height: 20px; cursor: pointer;">
                        <span>üìÑ JSON</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="checkXML" checked style="width: 20px; height: 20px; cursor: pointer;">
                        <span>üìÑ XML</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="checkTXT" checked style="width: 20px; height: 20px; cursor: pointer;">
                        <span>üìÑ TXT</span>
                    </label>
                </div>
            </div>
            
            <button class="process-btn" id="processBtn" style="display: none;">
                üöÄ Generate Index
            </button>
        </div>
        
        <div id="result"></div>
    </div>
    
    <script>
        // ==================== EVENT BUS (Event-Driven) ====================
        
        class EventBus {
            constructor() {
                this.listeners = {};
            }
            
            on(event, callback) {
                if (!this.listeners[event]) {
                    this.listeners[event] = [];
                }
                this.listeners[event].push(callback);
            }
            
            emit(event, data) {
                if (this.listeners[event]) {
                    this.listeners[event].forEach(callback => callback(data));
                }
            }
        }
        
        const eventBus = new EventBus();
        
        // ==================== FILTER FUNCTIONS ====================
        
        // Filter 1: Read directory
        async function filterReadDirectory(dirHandle) {
            const files = [];
            
            async function traverse(handle, path = '') {
                for await (const entry of handle.values()) {
                    if (entry.name.startsWith('.')) continue;
                    
                    const fullPath = path ? `${path}/${entry.name}` : entry.name;
                    
                    files.push({
                        path: fullPath,
                        name: entry.name,
                        isDir: entry.kind === 'directory'
                    });
                    
                    // Event-Driven: Emit progress
                    eventBus.emit('progress', {
                        step: 'reading',
                        count: files.length,
                        message: `Reading... ${files.length} items`
                    });
                    
                    // UI yielding every 50 files
                    if (files.length % 50 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    
                    // Safety limit
                    if (files.length > 10000) {
                        throw new Error('Too many items! Limit: 10,000 files. Try a smaller folder.');
                    }
                    
                    // Recurse if directory
                    if (entry.kind === 'directory') {
                        await traverse(entry, fullPath);
                    }
                }
            }
            
            await traverse(dirHandle);
            return files;
        }
        
        // Filter 2: Sort files
        function filterSort(files) {
            return [...files].sort((a, b) => {
                if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
                return a.path.localeCompare(b.path);
            });
        }
        
        // Filter 3: Build hierarchy with numbering
        function filterBuildHierarchy(files) {
            const tree = [];
            
            files.forEach(file => {
                const parts = file.path.split('/').filter(p => p);
                let current = tree;
                let numbering = [];
                let currentPath = '';
                
                parts.forEach((part, index) => {
                    currentPath = currentPath ? `${currentPath}/${part}` : part;
                    const isLast = index === parts.length - 1;
                    
                    let existing = current.find(item => item.name === part);
                    
                    if (!existing) {
                        const position = current.length + 1;
                        numbering.push(position);
                        
                        existing = {
                            number: numbering.join('.'),
                            name: part,
                            type: isLast && !file.isDir ? 'file' : 'directory',
                            path: currentPath,
                            children: []
                        };
                        
                        current.push(existing);
                    } else {
                        numbering = existing.number.split('.').map(Number);
                    }
                    
                    current = existing.children;
                });
            });
            
            return tree;
        }
        
        // Output Filter: Convert to JSON
        function filterToJSON(data) {
            return JSON.stringify(data, null, 2);
        }
        
        // Output Filter: Convert to XML
        function filterToXML(data) {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += `<directory_index root_path="${escapeXml(data.root)}">\n`;
            
            function addItems(items, indent = 1) {
                const spaces = '  '.repeat(indent);
                items.forEach(item => {
                    xml += `${spaces}<item number="${item.number}" type="${item.type}">\n`;
                    xml += `${spaces}  <name>${escapeXml(item.name)}</name>\n`;
                    xml += `${spaces}  <path>${escapeXml(item.path)}</path>\n`;
                    if (item.children && item.children.length > 0) {
                        xml += `${spaces}  <children>\n`;
                        addItems(item.children, indent + 2);
                        xml += `${spaces}  </children>\n`;
                    }
                    xml += `${spaces}</item>\n`;
                });
            }
            
            addItems(data.hierarchy);
            xml += '</directory_index>';
            return xml;
        }
        
        // Output Filter: Convert to TXT
        function filterToTXT(data) {
            let txt = `Directory Index: ${data.root}\n`;
            txt += '='.repeat(80) + '\n\n';
            
            function formatItem(item, depth = 0) {
                const indent = '  '.repeat(depth);
                const icon = item.type === 'directory' ? 'üìÅ' : 'üìÑ';
                let result = `${indent}${item.number}. ${icon} ${item.name}\n`;
                
                if (item.children) {
                    item.children.forEach(child => {
                        result += formatItem(child, depth + 1);
                    });
                }
                
                return result;
            }
            
            data.hierarchy.forEach(item => {
                txt += formatItem(item);
            });
            
            return txt;
        }
        
        // ==================== PIPELINE CLASS ====================
        
        class Pipeline {
            constructor(name = 'Pipeline') {
                this.filters = [];
                this.name = name;
            }
            
            addFilter(filterFunc, filterName = null) {
                this.filters.push({ func: filterFunc, name: filterName || filterFunc.name });
                return this;
            }
            
            async execute(input) {
                let data = input;
                
                for (let i = 0; i < this.filters.length; i++) {
                    const { func, name } = this.filters[i];
                    
                    // Event-Driven: Emit step progress
                    eventBus.emit('pipeline', {
                        step: i + 1,
                        total: this.filters.length,
                        filterName: name,
                        message: `Step ${i + 1}/${this.filters.length}: ${name}`
                    });
                    
                    // Execute filter
                    data = await func(data);
                    
                    // UI yield
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                return data;
            }
        }
        
        // ==================== STATE & GLOBALS ====================
        
        let selectedFiles = [];
        let folderName = '';
        let folderHandle = null;
        let hierarchy = [];
        
        // ==================== EVENT LISTENERS (Event-Driven UI) ====================
        
        // Progress event listener
        eventBus.on('progress', (data) => {
            const btn = document.getElementById('selectBtn');
            btn.textContent = `‚è≥ ${data.message}`;
            
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            progressBar.classList.add('show');
            
            // Estimate progress (rough)
            const percentage = Math.min((data.count / 100) * 10, 90);
            progressFill.style.width = `${percentage}%`;
        });
        
        // Pipeline step event listener
        eventBus.on('pipeline', (data) => {
            const btn = document.getElementById('processBtn');
            btn.textContent = `‚è≥ ${data.message}`;
            
            const progressFill = document.getElementById('progressFill');
            const percentage = (data.step / data.total) * 100;
            progressFill.style.width = `${percentage}%`;
        });
        
        // Complete event listener
        eventBus.on('complete', (data) => {
            const progressBar = document.getElementById('progressBar');
            progressBar.classList.remove('show');
            
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = '0%';
        });
        
        // Error event listener
        eventBus.on('error', (error) => {
            showError(error.message);
            
            const progressBar = document.getElementById('progressBar');
            progressBar.classList.remove('show');
            
            const selectBtn = document.getElementById('selectBtn');
            selectBtn.disabled = false;
            selectBtn.textContent = 'üìÇ Select Folder from Your Device';
            
            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = false;
            processBtn.textContent = 'üöÄ Generate Index';
        });
        
        // ==================== UI HANDLERS ====================
        
        // Check browser compatibility
        if (!('showDirectoryPicker' in window)) {
            document.getElementById('compatWarning').style.display = 'block';
            setupFileInputFallback();
        }
        
        document.getElementById('selectBtn').addEventListener('click', async () => {
            try {
                if ('showDirectoryPicker' in window) {
                    await selectFolderModern();
                } else {
                    document.getElementById('fileInput')?.click();
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    eventBus.emit('error', error);
                }
            }
        });
        
        async function selectFolderModern() {
            try {
                folderHandle = await window.showDirectoryPicker();
                folderName = folderHandle.name;
                
                document.getElementById('selectBtn').disabled = true;
                document.getElementById('selectBtn').textContent = '‚è≥ Scanning...';
                
                // Build pipeline for reading
                const readPipeline = new Pipeline('Read Pipeline');
                selectedFiles = await readPipeline
                    .addFilter(filterReadDirectory, 'Read Directory')
                    .execute(folderHandle);
                
                eventBus.emit('complete', { step: 'reading' });
                
                document.getElementById('folderName').textContent = folderName;
                document.getElementById('fileCount').textContent = selectedFiles.length;
                document.getElementById('selectedInfo').classList.add('show');
                document.getElementById('formatOptions').style.display = 'block';
                document.getElementById('processBtn').style.display = 'block';
                document.getElementById('selectBtn').disabled = false;
                document.getElementById('selectBtn').textContent = 'üìÇ Select Another Folder';
            } catch (error) {
                document.getElementById('selectBtn').disabled = false;
                document.getElementById('selectBtn').textContent = 'üìÇ Select Folder from Your Device';
                
                if (error.message !== 'File limit exceeded') {
                    console.error('Error reading folder:', error);
                    eventBus.emit('error', error);
                }
            }
        }
        
        function setupFileInputFallback() {
            const input = document.createElement('input');
            input.type = 'file';
            input.id = 'fileInput';
            input.webkitdirectory = true;
            input.multiple = true;
            input.style.display = 'none';
            document.body.appendChild(input);
            
            input.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                
                if (files.length > 10000) {
                    alert('‚ö†Ô∏è Too many files (>10,000)!\n\nFor large folders, use the command-line tool on desktop.');
                    return;
                }
                
                folderName = files[0].webkitRelativePath.split('/')[0];
                
                selectedFiles = files.map(file => ({
                    path: file.webkitRelativePath.split('/').slice(1).join('/'),
                    isDir: false,
                    name: file.name
                }));
                
                const dirs = new Set();
                files.forEach(file => {
                    const parts = file.webkitRelativePath.split('/');
                    for (let i = 1; i < parts.length - 1; i++) {
                        dirs.add(parts.slice(1, i + 1).join('/'));
                    }
                });
                
                dirs.forEach(dir => {
                    selectedFiles.push({
                        path: dir,
                        isDir: true,
                        name: dir.split('/').pop()
                    });
                });
                
                selectedFiles.sort((a, b) => a.path.localeCompare(b.path));
                
                document.getElementById('folderName').textContent = folderName;
                document.getElementById('fileCount').textContent = selectedFiles.length;
                document.getElementById('selectedInfo').classList.add('show');
                document.getElementById('formatOptions').style.display = 'block';
                document.getElementById('processBtn').style.display = 'block';
            });
        }
        
        document.getElementById('processBtn').addEventListener('click', generateIndex);
        
        async function generateIndex() {
            const btn = document.getElementById('processBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Processing...';
            
            document.getElementById('progressBar').classList.add('show');
            
            const genJSON = document.getElementById('checkJSON').checked;
            const genXML = document.getElementById('checkXML').checked;
            const genTXT = document.getElementById('checkTXT').checked;
            
            if (!genJSON && !genXML && !genTXT) {
                eventBus.emit('error', { message: 'Please select at least one format to generate!' });
                btn.disabled = false;
                btn.textContent = 'üöÄ Generate Index';
                return;
            }
            
            try {
                // Build processing pipeline
                const processPipeline = new Pipeline('Process Pipeline');
                
                hierarchy = await processPipeline
                    .addFilter(filterSort, 'Sort Files')
                    .addFilter(filterBuildHierarchy, 'Build Hierarchy')
                    .execute(selectedFiles);
                
                const data = {
                    root: folderName,
                    hierarchy: hierarchy
                };
                
                // Generate selected formats using output filters
                const outputs = {};
                if (genJSON) outputs.json = filterToJSON(data);
                if (genXML) outputs.xml = filterToXML(data);
                if (genTXT) outputs.txt = filterToTXT(data);
                
                eventBus.emit('complete', { step: 'processing' });
                
                // Show result
                const result = document.getElementById('result');
                result.className = 'show success';
                
                let downloadButtons = '';
                if (outputs.json) {
                    downloadButtons += `<button class="download-btn" onclick="downloadFileContent(window.outputs.json, 'directory_index.json', 'application/json')">üìÑ Download JSON</button>`;
                }
                if (outputs.xml) {
                    downloadButtons += `<button class="download-btn" onclick="downloadFileContent(window.outputs.xml, 'directory_index.xml', 'application/xml')">üìÑ Download XML</button>`;
                }
                if (outputs.txt) {
                    downloadButtons += `<button class="download-btn" onclick="downloadFileContent(window.outputs.txt, 'directory_index.txt', 'text/plain')">üìÑ Download TXT</button>`;
                }
                
                window.outputs = outputs;
                
                result.innerHTML = `
                    <h3>‚úÖ Index Generated!</h3>
                    <p><strong>Folder:</strong> ${folderName}</p>
                    <p><strong>Items:</strong> ${selectedFiles.length}</p>
                    <p style="margin-top: 15px;"><strong>Tap to download:</strong></p>
                    <div style="margin: 10px 0;">
                        ${downloadButtons}
                    </div>
                    ${outputs.txt ? '<div class="preview">' + escapeHtml(outputs.txt) + '</div>' : ''}
                `;
                
            } catch (error) {
                eventBus.emit('error', error);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üöÄ Generate Index';
            }
        }
        
        // ==================== UTILITY FUNCTIONS ====================
        
        function downloadFileContent(content, filename, mimeType) {
            try {
                const blob = new Blob([content], { type: mimeType || 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Downloaded!';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
            } catch (error) {
                alert('Error downloading file: ' + error.message);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeXml(str) {
            return str.replace(/[<>&'"]/g, char => {
                switch (char) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case "'": return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }
        
        function showError(message) {
            const result = document.getElementById('result');
            result.className = 'show error';
            result.innerHTML = `<h3>‚ùå Error</h3><p>${message}</p>`;
        }
        
        // Service Worker registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('app/static/sw.js')
                .catch(err => console.log('SW registration failed'));
        }
    </script>
</body>
</html>
